local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

local aimlockEnabled = false
local currentTarget = nil

-- Prüft, ob ein Spieler als Ziel in Frage kommt:
local function isEligible(player)
    if player == localPlayer then return false end
    if not player.Character then return false end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local head = player.Character:FindFirstChild("Head")
    if not humanoid or not head then return false end
    if humanoid.Health < 1 then return false end
    if localPlayer.Team and player.Team and localPlayer.Team == player.Team then
        return false
    end
    return true
end

-- Liefert alle eligible Spieler sortiert nach Entfernung (vom Head des lokalen Spielers):
local function getEligibleTargets()
    local targets = {}
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("Head")) then
        return targets
    end
    local myPos = localPlayer.Character.Head.Position
    for _, player in pairs(Players:GetPlayers()) do
        if isEligible(player) then
            local head = player.Character.Head
            local distance = (myPos - head.Position).Magnitude
            table.insert(targets, {player = player, distance = distance})
        end
    end
    table.sort(targets, function(a, b)
        return a.distance < b.distance
    end)
    return targets
end

-- Gibt den nächstgelegenen eligible Gegner zurück:
local function getNearestTarget()
    local targets = getEligibleTargets()
    if #targets > 0 then
        return targets[1].player
    end
    return nil
end

-- Wechselt mit MouseButton4 zum nächsten Ziel in der sortierten Liste:
local function cycleTarget()
    local targets = getEligibleTargets()
    if #targets == 0 then
        currentTarget = nil
        return
    end
    if not currentTarget then
        currentTarget = targets[1].player
    else
        local currentIndex = nil
        for i, t in ipairs(targets) do
            if t.player == currentTarget then
                currentIndex = i
                break
            end
        end
        if currentIndex then
            local nextIndex = currentIndex + 1
            if nextIndex > #targets then
                nextIndex = 1
            end
            currentTarget = targets[nextIndex].player
        else
            currentTarget = targets[1].player
        end
    end
end

-- Eingabeverarbeitung:
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Q then
        aimlockEnabled = not aimlockEnabled
        if aimlockEnabled then
            currentTarget = getNearestTarget()
            print("Aimlock aktiviert. Ziel: ", currentTarget and currentTarget.Name or "kein Ziel")
        else
            currentTarget = nil
            print("Aimlock deaktiviert.")
        end
    elseif input.KeyCode == Enum.KeyCode.MouseButton4 then
        if aimlockEnabled then
            cycleTarget()
            print("Ziel gewechselt. Neues Ziel: ", currentTarget and currentTarget.Name or "kein Ziel")
        end
    end
end)

-- Kamera-Ausrichtung pro Frame:
RunService.RenderStepped:Connect(function()
    if aimlockEnabled then
        -- Falls das aktuelle Ziel ungültig ist, wähle automatisch den nächstgelegenen eligible Gegner:
        if not currentTarget or not isEligible(currentTarget) then
            currentTarget = getNearestTarget()
        end
        if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild("Head") then
            local camera = workspace.CurrentCamera
            local targetHead = currentTarget.Character.Head
            camera.CFrame = CFrame.new(camera.CFrame.Position, targetHead.Position)
        end
    end
end)
